"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../../../common/types");
const xml_js_1 = require("xml-js");
const view_controller_generator_1 = require("../view-controller-generator");
const i18next_1 = __importDefault(require("i18next"));
const extensionLogger_1 = require("../../../../extensionLogger");
const v2_1 = require("../../../../specification/v2");
const manifest_1 = require("../manifest");
exports.FRAGMENT_DEFINITION = 'core:FragmentDefinition';
const VIEW_TEMPLATE_TAGNAME_MAP = new Map([
    [types_1.ViewTemplateType.AnalyticalTableColumnsExtension, 'table:AnalyticalColumn'],
    [types_1.ViewTemplateType.ResponsiveTableColumnsExtension, 'Column'],
    [types_1.ViewTemplateType.TreeTableColumnsExtension, 'table:Column'],
    [types_1.ViewTemplateType.GridTableColumnsExtension, 'table:Column']
]);
const FE_TEMPLATE_VIEW_EXTENSION_MAP = new Map([
    [v2_1.FE_TEMPLATE_V2_LIST_REPORT, v2_1.SAPUI5_VIEW_EXTENSION_LIST_REPORT],
    [v2_1.FE_TEMPLATE_V2_ALP, v2_1.SAPUI5_VIEW_EXTENSION_ANALYTICAL_LIST_PAGE],
    [v2_1.FE_TEMPLATE_V2_OBJECT_PAGE, v2_1.SAPUI5_VIEW_EXTENSION_OBJECT_PAGE]
]);
/**
 * Method which receives fragment definition node and returns 'tag' name of root column definition.
 * There is different column definition names - method resolves them.
 * For example 'Column', 'table:Column', etc.
 * @param {unknown} definition - Application or Page Config object.
 * @returns {unknown | undefined} Root column tag name.
 */
function getTagNameFromFragmentJSON(definition) {
    const keys = VIEW_TEMPLATE_TAGNAME_MAP.keys();
    for (const key of keys) {
        const tagName = VIEW_TEMPLATE_TAGNAME_MAP.get(key);
        if (definition[tagName]) {
            return tagName;
        }
    }
}
exports.getTagNameFromFragmentJSON = getTagNameFromFragmentJSON;
/**
 * Method which receives fragment definition node and reads root column definition.
 * @param {unknown} definition - Application or Page Config object.
 * @returns {unknown | undefined} Root column read from definition.
 */
function getRootCustomColumnFromFragmentJSON(definition) {
    const name = getTagNameFromFragmentJSON(definition);
    return definition[name];
}
exports.getRootCustomColumnFromFragmentJSON = getRootCustomColumnFromFragmentJSON;
/**
 * Internal function handling a single fragment column if detected in the fragment
 * @param columnsInFragment - list of all columns in fragment
 * @param configColumns - list of all columns in the config
 */
function handleFragmentColumn(columnsInFragment, configColumns) {
    let foundInConfig = false;
    const customData = columnsInFragment['customData'] || columnsInFragment['table:customData'];
    if (customData) {
        let p13nData = customData['core:CustomData']._attributes.value;
        const columnParts = JSON.parse(p13nData.substr(1, p13nData.length));
        const ix = configColumns.findIndex((column) => {
            return column.columnKey === columnParts.columnKey;
        });
        if (ix > -1) {
            //Found ==> update scenario
            foundInConfig = true;
            p13nData = '\\{"columnKey": "' + configColumns[ix].columnKey + '"';
            if (configColumns[ix].columnIndex !== undefined) {
                p13nData += ', "columnIndex": "' + configColumns[ix].columnIndex.toString() + '"';
            }
            if (configColumns[ix].leadingProperty) {
                p13nData += ', "leadingProperty": "' + configColumns[ix].leadingProperty + '"';
            }
            p13nData += '}';
            customData['core:CustomData']._attributes.value = p13nData;
            if (!columnsInFragment['Text'] && !columnsInFragment['Label']) {
                columnsInFragment['Text'] = {
                    _attributes: {}
                };
            }
            if (columnsInFragment['Text']) {
                columnsInFragment['Text']._attributes['text'] = configColumns[ix].text;
            }
            else if (columnsInFragment['Label']) {
                columnsInFragment['Label']._attributes['text'] = configColumns[ix].text;
            }
            if (!columnsInFragment['_attributes']) {
                columnsInFragment['_attributes'] = {};
            }
            columnsInFragment['_attributes']['id'] = configColumns[ix].id;
            configColumns.splice(ix, 1);
        }
        return foundInConfig;
    }
}
/**
 * The function transfers ALL properties of the given config object to a given fragment, or creates a new one if necesary.
 * @param fragments - list of fragment files
 * @param manifestSection - current section of the manifest, describing the extension
 * @param config - current config part, describing the new image of the extension
 * @param appId - application ID
 */
function exportToFragment(exportResults, path, config, appId, viewTemplateType, logger) {
    const fragments = exportResults.fragments;
    const manifest = exportResults.manifest;
    let cellsFragmentName;
    //Find and adapt manifest
    let manifestSection = manifest_1.getManifestSectionByPathV2(manifest, path);
    const fragmentType = manifestSection['type'] ? manifestSection['type'].toLowerCase() : 'xml';
    manifestSection['fragmentName'] = config[0].fragmentName;
    manifestSection['className'] = config[0].className;
    manifestSection['type'] = fragmentType.toUpperCase();
    if (path.indexOf(types_1.ViewTemplateType.ResponsiveTableColumnsExtension) > -1) {
        const cellsPath = path.replace(types_1.ViewTemplateType.ResponsiveTableColumnsExtension, types_1.ViewTemplateType.ResponsiveTableCellsExtension);
        manifestSection = manifest_1.getManifestSectionByPathV2(manifest, cellsPath);
        const cellsFragmentColumn = config.reduce((previousColumn, column) => {
            return column.cellsFragmentName ? column : previousColumn;
        });
        if (cellsFragmentColumn && cellsFragmentColumn.cellsFragmentName) {
            manifestSection['fragmentName'] = cellsFragmentName = cellsFragmentColumn.cellsFragmentName;
            manifestSection['className'] = config[0].className;
            manifestSection['type'] = fragmentType.toUpperCase();
        }
        else {
            manifest_1.deleteManifestSectionByPathV2(manifest, cellsPath);
        }
    }
    //Find and adapt fragment
    const configColumns = JSON.parse(JSON.stringify(config));
    let fragmentName = configColumns[0].fragmentName;
    if (!fragmentName) {
        extensionLogger_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('NOFRAGMENT', { columnKey: configColumns[0].columnKey })
        });
        return;
    }
    if (fragments) {
        const fragmentId = fragmentName.substr(appId.length + 1);
        let fragmentParts = fragmentId.split('.');
        let templateType = fragmentParts[fragmentParts.length - 1];
        fragmentName = templateType + '.fragment.' + fragmentType;
        //find and update the columns' fragment file
        for (let i = 0; i < fragments.length; i++) {
            const fragment = fragments[i];
            if (fragment['dataSourceUri'].endsWith(fragmentName)) {
                let columnsInFragmentDefinition = {};
                if (!fragment.fileContent || fragment.fileContent.length === 0) {
                    // Empty fragment - use template
                    fragment.fileContent = view_controller_generator_1.getColumnFragmentContent(configColumns, viewTemplateType);
                }
                else {
                    const fragmentJson = JSON.parse(xml_js_1.xml2json(fragment.fileContent, { compact: true }));
                    //find the right column in the fragment file
                    columnsInFragmentDefinition = getRootCustomColumnFromFragmentJSON(fragmentJson[exports.FRAGMENT_DEFINITION]);
                    if (columnsInFragmentDefinition) {
                        //find the right column in the identified fragment file
                        if (Array.isArray(columnsInFragmentDefinition)) {
                            for (let j = 0; j < columnsInFragmentDefinition.length; j++) {
                                const columnFoundInConfig = handleFragmentColumn(columnsInFragmentDefinition[j], configColumns);
                                if (!columnFoundInConfig) {
                                    columnsInFragmentDefinition.splice(j, 1);
                                    j = j - 1;
                                }
                            }
                        }
                        else {
                            const columnFoundInConfig = handleFragmentColumn(columnsInFragmentDefinition, configColumns);
                            if (!columnFoundInConfig) {
                                const tagName = getTagNameFromFragmentJSON(fragmentJson[exports.FRAGMENT_DEFINITION]);
                                if (tagName) {
                                    delete fragmentJson[exports.FRAGMENT_DEFINITION][tagName];
                                    columnsInFragmentDefinition = undefined;
                                }
                            }
                        }
                        //Insert scenario for the remaining entries
                        for (let j = 0; j < configColumns.length; j++) {
                            if (configColumns[j].fragmentName.endsWith(fragmentId)) {
                                const newColumnFragment = view_controller_generator_1.getSingleColumnContent(configColumns[j], viewTemplateType);
                                if (newColumnFragment) {
                                    const newColumnDefinition = JSON.parse(xml_js_1.xml2json(newColumnFragment, { compact: true }));
                                    const newColumn = getRootCustomColumnFromFragmentJSON(newColumnDefinition);
                                    if (Array.isArray(columnsInFragmentDefinition)) {
                                        columnsInFragmentDefinition.push(newColumn);
                                    }
                                    else {
                                        if (columnsInFragmentDefinition) {
                                            columnsInFragmentDefinition = [columnsInFragmentDefinition, newColumn];
                                        }
                                        else {
                                            columnsInFragmentDefinition = [newColumn];
                                        }
                                    }
                                }
                            }
                        }
                        const tagName = VIEW_TEMPLATE_TAGNAME_MAP.get(viewTemplateType);
                        fragmentJson[exports.FRAGMENT_DEFINITION][tagName] = columnsInFragmentDefinition;
                        fragment.fileContent = xml_js_1.json2xml(JSON.stringify(fragmentJson), { compact: true, spaces: 4 });
                    }
                }
                break;
            }
        }
        if (cellsFragmentName) {
            //find an update the cells' fragment file
            fragmentParts = cellsFragmentName.split('.');
            templateType = fragmentParts[fragmentParts.length - 1];
            fragmentName = templateType + '.fragment.' + fragmentType;
            for (let i = 0; i < fragments.length; i++) {
                const fragment = fragments[i];
                if (fragment['dataSourceUri'].endsWith(fragmentName)) {
                    if (!fragment.fileContent || Object.keys(fragment.fileContent).length === 0) {
                        // Empty fragment - use template
                        fragment.fileContent = view_controller_generator_1.getResponsiveTableCellsFragment(config);
                    }
                    else {
                        const fragmentJson = JSON.parse(xml_js_1.xml2json(fragment.fileContent));
                        const fragmentColumns = fragmentJson.elements[0].elements &&
                            fragmentJson.elements[0].elements.filter((element) => {
                                return element.type === 'element';
                            });
                        if (!fragmentColumns || Object.keys(fragmentColumns).length !== Object.keys(config).length) {
                            const dummyEntry = {
                                type: 'element',
                                name: 'Text',
                                attributes: { text: 'Placeholder' }
                            };
                            const dummyEntryAsString = JSON.stringify(dummyEntry);
                            if (!fragmentColumns || Object.keys(fragmentColumns).length < Object.keys(config).length) {
                                const startIndex = fragmentColumns ? Object.keys(fragmentColumns).length : 0;
                                if (!fragmentJson.elements[0].elements) {
                                    fragmentJson.elements[0].elements = [];
                                }
                                for (let index = startIndex; index < Object.keys(config).length; index++) {
                                    fragmentJson.elements[0].elements.push(dummyEntry);
                                }
                            }
                            else if (Object.keys(fragmentColumns).length > Object.keys(config).length) {
                                //only dummy entry will be deleted automatically!
                                let noOfEntriesToBeDeleted = Object.keys(fragmentColumns).length - Object.keys(config).length;
                                for (let index = 0; index < Object.keys(fragmentJson.elements[0].elements).length; index++) {
                                    if (JSON.stringify(fragmentJson.elements[0].elements[index]) === dummyEntryAsString) {
                                        fragmentJson.elements[0].elements.splice(index, 1);
                                        noOfEntriesToBeDeleted -= 1;
                                        if (noOfEntriesToBeDeleted === 0) {
                                            break;
                                        }
                                    }
                                }
                            }
                            fragment.fileContent = xml_js_1.json2xml(JSON.stringify(fragmentJson), { spaces: 4 });
                        }
                    }
                }
            }
        }
    }
}
exports.exportToFragment = exportToFragment;
/**
 * Determines the manifest path of a column extension.
 * @param {string[]} page Page object from manifest.
 * @param {string} entitySet Table's entity set.
 * @param {string} [additionalKey] Key provided when defining the FacetID or QuickVariantSelectionX.
 * @param {string} [tableColumnExtensionType] Column extension type.
 */
exports.getCustomColumnPath = (page, entitySet, additionalKey, tableColumnExtensionType) => {
    const extension = FE_TEMPLATE_VIEW_EXTENSION_MAP.get(page.component.name);
    if (!tableColumnExtensionType) {
        let tableType = page.component.settings &&
            page.component.settings.tableSettings &&
            page.component.settings.tableSettings['type'];
        if (!tableType) {
            tableType = 'ResponsiveTable';
        }
        if (extension === 'sap.suite.ui.generic.template.AnalyticalListPage.view.AnalyticalListPage') {
            tableType = 'AnalyticalTable';
        }
        tableColumnExtensionType = tableType + 'ColumnsExtension';
    }
    const viewTemplateType = tableColumnExtensionType;
    let extensionKey = `${tableColumnExtensionType}|${entitySet}`;
    if (additionalKey) {
        extensionKey += '|' + additionalKey;
    }
    const path = 'sap.ui5/extends/extensions/sap.ui.viewExtensions/' + extension + '/' + extensionKey;
    return { path, viewTemplateType };
};
//# sourceMappingURL=Fragment.js.map
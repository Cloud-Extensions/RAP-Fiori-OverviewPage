"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../../common");
const controls_1 = require("../export/controls");
const decorators_1 = require("../../common/decoration/decorators");
const path_1 = require("path");
exports.CUSTOM_COLUMNS_DEFINITION = 'TableCustomColumns';
exports.CUSTOM_COLUMN_DEFINITION = 'TableCustomColumn';
/**
 * Adds the line item records to the app schema (for the list report or an object page section comprising a table)
 * @param appSchema - the app specific schema that shall get enhanced
 * @param lineItemAnnotation - the UI.LineItem annotation, comprising all records
 * @param entityType - the entity type as part of the AVT ConverterOutput
 * @param lineItemId - optional: in case of OP the paramter must be passed to distinguish the OP tables;
 *                      in case of LR or ALP no ID is passed, 'LineItems' is taken then.
 * @param customColumnRef - schema reference to custom column definition.
 */
function addLineItemsType(appSchema, lineItemAnnotation, entityType, lineItemId, customColumnRef) {
    let schemaKey;
    lineItemId = lineItemId || 'LineItems';
    appSchema['definitions'][lineItemId] = {
        type: 'object',
        properties: {},
        additionalProperties: false
    };
    if (lineItemAnnotation) {
        let i = 0;
        lineItemAnnotation.forEach((lineItemRecord) => {
            schemaKey = common_1.getSchemaKeyOfLineItemRecord(lineItemRecord);
            if (schemaKey) {
                appSchema['definitions'][lineItemId]['properties'][schemaKey] = {
                    $ref: '#/definitions/TableColumn',
                    description: common_1.getColumnDescription(lineItemRecord, entityType),
                    // Custom property in schema - for object properties ordering purpose
                    propertyIndex: i
                };
                i++;
            }
        });
    }
    if (customColumnRef) {
        appSchema['definitions'][lineItemId]['properties']['custom'] = {
            $ref: `#/definitions/${customColumnRef}`
        };
    }
}
exports.addLineItemsType = addLineItemsType;
/**
 * Adds enum entries of posible leading properties for 'leadingProperty' property in TableCustomColumn properties.
 * @param appSchema - the app specific schema that shall get enhanced
 * @param entityType - the entity type as part of the AVT ConverterOutput
 * @param definitionName - definition name of CustomColumn definition
 */
function addListReportLeadingProperties(appSchema, entityType, definitionName) {
    // Leading Property
    const leadingPropertySchema = appSchema['definitions'][definitionName] &&
        appSchema['definitions'][definitionName]['properties'] &&
        appSchema['definitions'][definitionName]['properties']['leadingProperty'];
    if (leadingPropertySchema) {
        const properties = [
            //  Entity properties
            ...(entityType.entityProperties || []),
            // Navigation Properties
            ...(entityType.navigationProperties || [])
        ];
        leadingPropertySchema['enum'] = properties.reduce((result, property) => {
            if (!result.includes(property.name)) {
                result.push(property.name);
            }
            return result;
        }, []);
    }
}
exports.addListReportLeadingProperties = addListReportLeadingProperties;
/**
 * Adds enum entries of posible tabKey properties for 'leadingProperty' property in TableCustomColumn properties.
 * @param appSchema - the app specific schema that shall get enhanced
 * @param definitionName - definition name of CustomColumn definition
 * @param page - sapui5 page object
 */
function addTabkeyEnum(appSchema, definitionName, page) {
    const tabkeyPropertySchema = appSchema['definitions'][definitionName] &&
        appSchema['definitions'][definitionName]['properties'] &&
        appSchema['definitions'][definitionName]['properties']['tabKey'];
    if (page) {
        const quickVariantsX = page.component &&
            page.component.settings &&
            page.component.settings.quickVariantSelectionX &&
            page.component.settings.quickVariantSelectionX['variants'];
        if (quickVariantsX) {
            const enumEntries = [];
            Object.keys(quickVariantsX).reduce((result, variant) => {
                const key = quickVariantsX[variant] && quickVariantsX[variant]['key'] !== undefined
                    ? quickVariantsX[variant]['key']
                    : undefined;
                // Avoid duplicates
                if (key !== undefined && !result.includes(key)) {
                    result.push(key);
                }
                return result;
            }, enumEntries);
            tabkeyPropertySchema['enum'] = enumEntries;
        }
    }
}
exports.addTabkeyEnum = addTabkeyEnum;
/**
 * Adds enum entries of posible fragment entries.
 * @param {object} appSchema The app specific schema that shall get enhanced.
 * @param {FileData[]} fragments Array of fragments.
 * @param {string[]} appId Application id.
 * @param {string} property Property name.
 * @param {string} definitionName Definition name of CustomColumn definition.
 */
function addFragmentEnum(appSchema, fragments, appId, property, definitionName) {
    const fragmentPropertySchema = appSchema['definitions'][definitionName] &&
        appSchema['definitions'][definitionName]['properties'] &&
        appSchema['definitions'][definitionName]['properties'][property];
    if (fragments && appId && !appId.startsWith('${')) {
        const enumEntries = [];
        fragments.forEach((fragment) => {
            let relPath = fragment.dataSourceUri.split('webapp')[1];
            if (relPath && relPath.indexOf('.fragment.xml') > 0) {
                relPath = relPath.replace(new RegExp('\\' + path_1.sep, 'g'), '/');
                const fragmentName = appId + relPath.split('.fragment.xml')[0].replace(/\//g, '.');
                enumEntries.push(fragmentName);
            }
        });
        if (enumEntries.length > 0) {
            fragmentPropertySchema['enum'] = enumEntries;
        }
    }
}
exports.addFragmentEnum = addFragmentEnum;
/**
 * Adds the custom columns to the line item records of the app schema (for the list report comprising a table).
 * @param {object} appSchema The app specific schema that shall get enhanced.
 * @param {EntityType} entityType The entity type as part of the AVT ConverterOutput.
 * @param {SapUiAppPageV2} page Sapui5 page object.
 * @param {object} manifest Application manifest.
 * @param {FileData[]} [fragments] Array of fragments.
 * @param {string} [customColumnsDefinitionName=CUSTOM_COLUMNS_DEFINITION] Definition name of Custom Columns definition.
 * @param {string} [customColumnDefinitionName=CUSTOM_COLUMN_DEFINITION] Definition name of Custom Column definition.
 */
function addListReportColumnExtensions(appSchema, entityType, page, manifest, fragments, customColumnsDefinitionName = exports.CUSTOM_COLUMNS_DEFINITION, customColumnDefinitionName = exports.CUSTOM_COLUMN_DEFINITION) {
    if (appSchema['definitions']['LineItems']) {
        appSchema['definitions']['LineItems']['properties']['custom'] = {
            $ref: `#/definitions/${customColumnsDefinitionName}`
        };
    }
    appSchema['definitions'][customColumnsDefinitionName] = {
        type: 'array',
        items: {
            $ref: `#/definitions/${customColumnDefinitionName}`
        }
    };
    // Leading Property
    addListReportLeadingProperties(appSchema, entityType, customColumnDefinitionName);
    // Tab key property
    addTabkeyEnum(appSchema, customColumnDefinitionName, page);
    // Fragment property
    const appId = manifest && manifest['sap.app'] && manifest['sap.app']['id'];
    addFragmentEnum(appSchema, fragments, appId, 'fragmentName', customColumnDefinitionName);
    addFragmentEnum(appSchema, fragments, appId, 'cellsFragmentName', customColumnDefinitionName);
}
exports.addListReportColumnExtensions = addListReportColumnExtensions;
/**
 * Apply post-processing rules as specified in form of "generate" at the syncRule
 * @param schema - given app schema, to be adapted
 */
function checkGenerateRules(schema) {
    let metaDataDefinition;
    for (const key in schema['definitions']) {
        const definition = schema['definitions'][key];
        switch (key) {
            case 'ObjectPageHeader':
                metaDataDefinition = new controls_1.ObjectPageHeader();
                break;
            case 'HeaderAction':
                metaDataDefinition = new controls_1.HeaderAction();
                break;
            case 'TableColumn':
                metaDataDefinition = new controls_1.TableColumn();
                break;
            case 'ResponsiveTableWithInlineDelete<LineItems>':
            case 'ResponsiveTableWithMultiSelect<LineItems>':
                metaDataDefinition = new controls_1.ResponsiveTable();
                break;
            default:
                if (key.startsWith('ObjectPageResponsiveTableWithInlineDelete') ||
                    key.startsWith('ObjectPageResponsiveTableWithMultiSelect')) {
                    metaDataDefinition = new controls_1.ObjectPageResponsiveTable();
                }
                break;
        }
        if (metaDataDefinition) {
            for (const propertyName in definition['properties']) {
                const property = definition['properties'][propertyName];
                metaDataDefinition[propertyName] = property;
                const syncRule = decorators_1.getReflectMetadata(metaDataDefinition, propertyName);
                if (syncRule) {
                    if (typeof syncRule.generate === 'function') {
                        syncRule.generate(schema, definition, propertyName);
                    }
                }
            }
        }
    }
}
exports.checkGenerateRules = checkGenerateRules;
/**
 * Method updates passed 'enum' array by removing passed matching entries.
 * @param {Array<unknown>} values Array of values.
 * @param {Array<unknown>} valuesToRemove Array of values to remove.
 */
function removeElementsFromEnum(values, valuesToRemove) {
    for (let i = 0; i < valuesToRemove.length; i++) {
        const index = values.indexOf(valuesToRemove[i]);
        if (index !== -1) {
            // Value exists - remove it
            values.splice(index, 1);
        }
    }
}
exports.removeElementsFromEnum = removeElementsFromEnum;
//# sourceMappingURL=utils.js.map
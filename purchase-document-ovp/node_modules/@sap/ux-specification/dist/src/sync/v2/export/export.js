"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const pages_1 = require("./pages");
const decorators_1 = require("../../common/decoration/decorators");
const controls_1 = require("./controls");
const AnalyticalListPageChart_1 = require("../../../sync/v2/export/controls/AnalyticalListPageChart");
const AnalyticalListPageKPI_1 = require("../../../sync/v2/export/controls/AnalyticalListPageKPI");
const utils_1 = require("../../common/utils");
const v2_1 = require("../../../v2");
const application_1 = require("../application");
const manifest_1 = require("./manifest");
const utils_2 = require("../import/utils");
const Card_1 = require("../../../specification/v2/controls/Card");
const common_1 = require("../../common");
const common_2 = require("../../../specification/common");
const ObjectPageHeaderAction_1 = require("../../../sync/v2/export/controls/ObjectPageHeaderAction");
const control_1 = require("../../common/decoration/control");
/**
 * Returns a fresh export results object with default values
 */
const getDefaultExportResult = (fragmentFiles) => ({
    flexChanges: [],
    manifest: {
        'sap.ui.generic.app': { pages: {} }
    },
    fragments: fragmentFiles ? fragmentFiles : []
});
/**
 * Create missing card from the manifest
 * @param key - card name
 * @param ovp - OVP section of manifest, to be updated
 */
function createCard(key, ovp) {
    if (!ovp.cards) {
        ovp.cards = {};
    }
    if (!(key in ovp.cards)) {
        ovp.cards[key] = {};
    }
}
/**
 * Recursive function that searches for next avaialble id by increasing number by 1.
 * @param {boolean} sectionIds All ids in use.
 * @param {string} candidateId Candidate id to check if it is available.
 * @return {string} Id string.
 */
function findAvailableId(sectionIds, candidateId) {
    if (sectionIds.includes(candidateId)) {
        const idParts = candidateId.split('|');
        if (idParts.length === 3) {
            idParts.push('1');
        }
        else {
            idParts[3] = (parseInt(idParts[3]) + 1).toString();
        }
        return findAvailableId(sectionIds, idParts.join('|'));
    }
    return candidateId;
}
/**
 * Private recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param configObject - current object to traverse
 * @param manifest - app descriptor (manifest.json)
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param jsonSchema - application specific schema
 * @param targetDefinition - the current entry point or definition in the app schema
 * @param pathHierarchy -  elements of the path indicating the hierarchical level
 */
function transferManifestEntriesOVP(configObject, manifest, exportResults, jsonSchema, targetDefinition, pathHierarchy) {
    if (targetDefinition) {
        if (targetDefinition['properties']) {
            processProperties(configObject, manifest, exportResults, jsonSchema, targetDefinition['properties'], pathHierarchy);
        }
        else if (targetDefinition['additionalProperties']) {
            processProperties(configObject, manifest, exportResults, jsonSchema, targetDefinition['additionalProperties'], pathHierarchy);
        }
    }
}
/**
 * Recursive function that transfers the content of a list of properties of a configuration to the overall exportResults
 * @param configObject - the given part of the configuration
 * @param manifest - manifest.json of the app
 * @param exportResults - overall result list, to be updated
 * @param jsonSchema - app-specific JSOn schema
 * @param propertyList - current property list of the config (properties or additional properties)
 * @param pathHierarchy -  elements of the path indicating the hierarchical level
 */
function processProperties(configObject, manifest, exportResults, jsonSchema, propertyList, pathHierarchy) {
    let currentObject;
    for (const key in propertyList) {
        currentObject = configObject[key];
        const syncRule = decorators_1.getReflectMetadata(configObject, key);
        if (syncRule) {
            if (syncRule.manifest) {
                const path = syncRule.manifest.path([...pathHierarchy, key]);
                const manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, path);
                if (key in v2_1.CardSettingsType) {
                    manifestSection['settings'] = currentObject ? currentObject : {};
                }
                else {
                    if (currentObject !== undefined) {
                        const exportHandler = syncRule.manifest.export;
                        if (exportHandler !== false) {
                            if (exportHandler && typeof exportHandler === 'function') {
                                exportHandler(manifestSection, configObject, key);
                            }
                            else {
                                manifestSection[key] = currentObject;
                            }
                        }
                    }
                    else if (manifestSection[key]) {
                        delete manifestSection[key];
                    }
                }
            }
        }
        if (currentObject && typeof currentObject === 'object' && propertyList[key]) {
            if (key === 'cards') {
                //inserts and updates:
                Object.keys(currentObject).forEach((newKey) => {
                    const cardType = currentObject[newKey].template;
                    switch (cardType) {
                        case Card_1.CardTemplateType.list:
                        case Card_1.CardTemplateType.listv4:
                            currentObject[newKey] = Object.assign(new controls_1.ListCard(), currentObject[newKey]);
                            break;
                        case Card_1.CardTemplateType.stack:
                            currentObject[newKey] = Object.assign(new controls_1.StackCard(), currentObject[newKey]);
                            break;
                        case Card_1.CardTemplateType.linklist:
                            currentObject[newKey] = Object.assign(new controls_1.LinklistCard(), currentObject[newKey]);
                            break;
                        case Card_1.CardTemplateType.table:
                        case Card_1.CardTemplateType.tablev4:
                            currentObject[newKey] = Object.assign(new controls_1.TableCard(), currentObject[newKey]);
                            break;
                        case Card_1.CardTemplateType.analytical:
                        case Card_1.CardTemplateType.analyticalv4:
                            currentObject[newKey] = Object.assign(new controls_1.AnalyticalCard(), currentObject[newKey]);
                            break;
                        default:
                            currentObject[newKey] = Object.assign(new controls_1.CustomCard(), currentObject[newKey]);
                            break;
                    }
                    createCard(newKey, exportResults['manifest']['sap.ovp']);
                    let targetDefinition;
                    if (!Object.values(Card_1.CardTemplateType).includes(cardType)) {
                        targetDefinition = ['CustomCard'];
                    }
                    else {
                        targetDefinition = Object.keys(jsonSchema['definitions']).filter((definition) => jsonSchema['definitions'][definition].properties &&
                            jsonSchema['definitions'][definition].properties.template &&
                            jsonSchema['definitions'][definition].properties.template.enum &&
                            jsonSchema['definitions'][definition].properties.template.enum.indexOf(currentObject[newKey].template) > -1);
                    }
                    transferManifestEntriesOVP(currentObject[newKey], manifest, exportResults, jsonSchema, jsonSchema['definitions'][targetDefinition[0]], [newKey]);
                });
                //check for deletions:
                Object.keys(manifest['sap.ovp'].cards).forEach((manifestCard) => {
                    if (!currentObject[manifestCard]) {
                        delete exportResults.manifest['sap.ovp'].cards[manifestCard];
                    }
                });
            }
            else if (propertyList[key].$ref) {
                const definitionArray = propertyList[key].$ref.split('#/definitions/');
                const nextTargetDefinition = jsonSchema['definitions'][definitionArray[definitionArray.length - 1]];
                const cardSettingsType = key;
                switch (cardSettingsType) {
                    case v2_1.CardSettingsType.listCardSettings:
                        currentObject = Object.assign(new controls_1.ListCard(), currentObject);
                        break;
                    case v2_1.CardSettingsType.stackCardSettings:
                        currentObject = Object.assign(new controls_1.StackCard(), currentObject);
                        break;
                    case v2_1.CardSettingsType.linkListCardSettings:
                        currentObject = Object.assign(new controls_1.LinklistCard(), currentObject);
                        break;
                    case v2_1.CardSettingsType.tableCardSettings:
                        currentObject = Object.assign(new controls_1.TableCard(), currentObject);
                        break;
                    case v2_1.CardSettingsType.analyticalCardSettings:
                        currentObject = Object.assign(new controls_1.AnalyticalCard(), currentObject);
                        break;
                    default:
                        currentObject = Object.assign(new controls_1.CustomCard(), currentObject);
                        break;
                }
                transferManifestEntriesOVP(currentObject, manifest, exportResults, jsonSchema, nextTargetDefinition, [
                    ...pathHierarchy,
                    key
                ]);
            }
            else if (propertyList[key].anyOf) {
                processProperties(configObject, manifest, exportResults, jsonSchema, propertyList[key].anyOf, pathHierarchy);
            }
        }
    }
}
/**
 * Evaluates an export rule for a property or object, transfers to flex change or manifest setting
 * @param syncRule - export rule from the object classes decorator
 * @param configObject - current (sub)object of the configuration file
 * @param breadcrumbs - list of breadcrumbs, i.e. ID parts for building the stable ID
 * @param baseId - selector id of the current page
 * @param ids - list of parent & child ids
 * @param title - title from the app schema (comprising for instance the facet ID)
 * @param key - key of the given property
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param fullManifest - old or existing manifest
 * @param pageKeys - array of keys to identify component in manifest
 * @param manifestSection - current manifest section
 */
function evaluateExportRule(syncRule, configObject, breadcrumbs, baseId, ids, title, key, exportResults, fullManifest, pageKeys, manifestSection, ui5Version) {
    function getManifestPath() {
        let path;
        if (breadcrumbs[0] === 'sections') {
            if (breadcrumbs[1] === 'custom') {
                path = syncRule.manifest.path(pageKeys, {}, breadcrumbs[2]);
            }
            else {
                path = syncRule.manifest.path(pageKeys, {}, breadcrumbs[1]);
                path = path.replace('/@', '::').replace(/::@com.sap.vocabularies/g, '::com.sap.vocabularies');
            }
        }
        else if (breadcrumbs[0] === 'table') {
            if (breadcrumbs[1] === 'columns' && breadcrumbs[2] === 'custom') {
                path = syncRule.manifest.path(pageKeys, fullManifest, configObject['tabKey']);
            }
            else {
                path = syncRule.manifest.path(pageKeys, {}, breadcrumbs[1]);
            }
        }
        else if (breadcrumbs[0] === 'keyPerformanceIndicators') {
            path = syncRule.manifest.path(pageKeys, fullManifest, title);
        }
        else {
            path = syncRule.manifest.path(pageKeys);
        }
        return path;
    }
    let localBreadcrumbs;
    //eliminate subsections' hierarchy
    let index = breadcrumbs.indexOf('subsections');
    while (index > -1) {
        breadcrumbs.splice(index - 1, 2);
        index = breadcrumbs.indexOf('subsections');
    }
    if (syncRule.flex) {
        if (breadcrumbs.length === 0) {
            //only added on top = page level, do not forward
            localBreadcrumbs = ['page'];
        }
        else {
            localBreadcrumbs = breadcrumbs;
        }
        const flexChange = common_1.createFlexChange(configObject, localBreadcrumbs, syncRule, ui5Version, baseId, ids, title, key);
        exportResults.flexChanges.push(syncRule.flex.exportFunction(flexChange, fullManifest));
    }
    else if (syncRule.manifest) {
        const path = getManifestPath();
        manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, path);
        const manifestKey = syncRule.manifest.key || key;
        if (configObject[key] !== undefined) {
            const exportHandler = syncRule.manifest.export;
            if (exportHandler !== false) {
                if (exportHandler && typeof exportHandler === 'function') {
                    exportHandler(manifestSection, configObject, key);
                }
                else {
                    manifestSection[manifestKey] = configObject[key];
                }
            }
        }
        else {
            if (Object.prototype.hasOwnProperty.call(manifestSection, manifestKey)) {
                delete manifestSection[manifestKey];
            }
        }
        common_1.deleteEmptyStructure(exportResults.manifest, path);
    }
}
/**
 * Instantiates the export classes for the object page section
 * @param objectPageConfig - the given object page configuration
 * @param objectPage - the overall object page export class where the sections shall be included
 */
function getExportClassesForSections(objectPageConfig, objectPage, v2Page) {
    /**
     * Instantiates the export classes for a single object page section
     * @param section - Export class as an object, to be updated
     * @param sectionId - Current section ID
     */
    function getClassesForSingleSection(section, sectionId, sectionInManifest) {
        let tableType = v2_1.TableTypeV2.ResponsiveTable;
        if (section) {
            if (section['chart'] || sectionId.includes('com.sap.vocabularies.UI.v1.Chart')) {
                section['chart'] = Object.assign(new controls_1.ObjectPageChart(), section['chart']);
                return;
            }
            if (section['table']) {
                //listed in config
                tableType = section['table'].type;
            }
            else if (sectionInManifest) {
                //only listed in manifest, deleted from config
                tableType = sectionInManifest['tableSettings'].type;
            }
            switch (tableType) {
                case v2_1.TableTypeV2.AnalyticalTable:
                    section['table'] = Object.assign(new controls_1.ObjectPageAnalyticalTable(), section['table']);
                    break;
                case v2_1.TableTypeV2.GridTable:
                    section['table'] = Object.assign(new controls_1.ObjectPageGridTable(), section['table']);
                    break;
                case v2_1.TableTypeV2.TreeTable:
                    section['table'] = Object.assign(new controls_1.ObjectPageTreeTable(), section['table']);
                    break;
                default:
                case v2_1.TableTypeV2.ResponsiveTable:
                    section['table'] = Object.assign(new controls_1.ObjectPageResponsiveTable(), section['table']);
                    break;
            }
            if (section['table'].columns) {
                for (const columnId in section['table'].columns) {
                    if (columnId === 'custom') {
                        continue;
                    }
                    section['table'].columns[columnId] = Object.assign(new controls_1.TableColumn(), section['table'].columns[columnId]);
                }
            }
            // custom section
            if (sectionId === 'custom' && Array.isArray(section)) {
                // Custom sections
                for (const index in section) {
                    section[index] = Object.assign(section[index].className === v2_1.SAPUI5_FRAGMENT_CLASS
                        ? new controls_1.ObjectPageCustomSectionFragment()
                        : new controls_1.ObjectPageCustomSectionView(), section[index]);
                }
            }
        }
    }
    /**
     * Recursive sub-function for handling subsections
     * @param section - Object page section in config
     */
    function getSubsectionClasses(section) {
        if (section['subsections']) {
            let subSection, sectionInManifest;
            for (const subSectionId in section['subsections']) {
                subSection = section['subsections'][subSectionId];
                sectionInManifest =
                    v2Page.component.settings &&
                        v2Page.component.settings.sections &&
                        v2Page.component.settings.sections[subSectionId];
                getClassesForSingleSection(subSection, subSectionId, sectionInManifest);
                getSubsectionClasses(subSection);
            }
        }
    }
    // Main function
    let section, sectionInManifest;
    for (const sectionId in objectPageConfig.sections) {
        section = objectPage.sections[sectionId];
        sectionInManifest =
            v2Page.component.settings &&
                v2Page.component.settings.sections &&
                v2Page.component.settings.sections[sectionId];
        getClassesForSingleSection(section, sectionId, sectionInManifest);
        getSubsectionClasses(section);
    }
}
function deleteFragment(manifestSection, pattern, appId, fragments) {
    if (fragments) {
        const fragmentId = manifestSection[pattern].fragmentName.substr(appId.length + 1);
        const fragmentType = manifestSection['type'] ? manifestSection['type'].toLowerCase() : 'xml';
        const fragmentParts = fragmentId.split('.');
        const fragmentName = fragmentParts[fragmentParts.length - 1] + '.fragment.' + fragmentType;
        //delete fragment file
        for (let i = 0; i < fragments.length; i++) {
            const fragment = fragments[i];
            if (fragment['dataSourceUri'].endsWith(fragmentName)) {
                fragments.splice(i, 1);
                break;
            }
        }
    }
}
/**
 * Transfers column extensions to manifest and fragment files
 * @param {TableCustomColumns} config - config part comprising the table custom columns
 * @param {ExportResults} exportResults - object with all collected manifest entries and flex changes
 * @param {string} appId - id of the Fiori elements app, which is usually namespace.appid
 * @param {object} schemaDefinition - Column schema definition
 * @param {SapUiAppPageV2} page - Page object from manifest.
 * @param {ObjectPageSectionData} [objectPageSectionData] - Object Page section's data containing target and key options.
 */
function transferColumnExtensions(config, exportResults, appId, schemaDefinition, logger, page, objectPageSectionData) {
    const sectionKey = objectPageSectionData ? objectPageSectionData.key : undefined;
    const sectionTarget = objectPageSectionData ? objectPageSectionData.target : undefined;
    const entitySet = sectionTarget || page.entitySet;
    for (const extensionType in v2_1.TableColumnExtensionTypeV2) {
        const { path, viewTemplateType } = controls_1.getCustomColumnPath(page, entitySet, sectionKey, extensionType);
        if (!path) {
            continue;
        }
        const folderPath = path.substr(0, path.lastIndexOf('/'));
        const manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, folderPath);
        const extensionPattern = path.substr(path.lastIndexOf('/') + 1);
        for (const key in manifestSection) {
            if (key.startsWith(extensionPattern)) {
                const [keyExtensionType, keyEntitySet, keyTab] = key.split('|');
                if (keyEntitySet === entitySet) {
                    //relevant extension. still present in config?
                    const existingConfigEntries = config.filter((column) => (column.tabKey === keyTab ||
                        (keyTab === undefined && column.tabKey === '') ||
                        (keyTab && sectionKey === keyTab)) &&
                        column.extensionType === extensionType);
                    if (!existingConfigEntries || existingConfigEntries.length === 0) {
                        deleteFragment(manifestSection, key, appId, exportResults.fragments);
                        // delete from manifest
                        delete manifestSection[key];
                        // delete cells entry
                        if (key.startsWith(common_1.ViewTemplateType.ResponsiveTableColumnsExtension)) {
                            const cellsPattern = key.replace(common_1.ViewTemplateType.ResponsiveTableColumnsExtension, common_1.ViewTemplateType.ResponsiveTableCellsExtension);
                            deleteFragment(manifestSection, cellsPattern, appId, exportResults.fragments);
                            // delete from manifest
                            delete manifestSection[cellsPattern];
                        }
                    }
                }
            }
        }
    }
    //cluster existing custom columns by manifest path (or tab key)
    const cluster = {};
    for (let index = 0; index < config.length; index++) {
        const customColumn = config[index];
        //verify that mandatory parameters are filled
        if (!customColumn['className'] ||
            !customColumn['fragmentName'] ||
            !customColumn['columnKey'] ||
            !customColumn['extensionType']) {
            continue;
        }
        //check fragment name
        if (schemaDefinition['properties']['fragmentName']['pattern']) {
            const namePattern = new RegExp(schemaDefinition['properties']['fragmentName']['pattern']);
            if (namePattern.test(customColumn['fragmentName']) === false) {
                continue;
            }
        }
        const { path, viewTemplateType } = controls_1.getCustomColumnPath(page, entitySet, customColumn.tabKey || sectionKey, customColumn['extensionType']);
        if (!cluster[path]) {
            cluster[path] = {
                viewTemplateType: viewTemplateType,
                columns: []
            };
        }
        cluster[path].columns.push(customColumn);
    }
    //Export to fragment
    for (const path in cluster) {
        controls_1.exportToFragment(exportResults, path, cluster[path].columns, appId, cluster[path].viewTemplateType, logger);
    }
}
/**
 * Recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param configSections - sections from configuration object
 * @param pageKey  - page key
 * @param fullManifest - the complete manifest.json file content
 * @param parentIds - array of collected parent ids
 * @param manifest - app descriptor (manifest.json)
 * @param breadcrumbs - array of properties that we are currently processing. Required for instance for table column name
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param baseId - selector id of the current page
 * @param pageKeys - array of keys to identify component in manifest
 * @param jsonSchema - application specific schema
 * @param targetDefinition - the current entry point or definition in the app schema
 * @param entityAnnotations - list of annotations of the entity type that the page is referring to
 */
function transferManifestExtensions(configSections, pageKey, fullManifest, parentIds, manifest, breadcrumbs, exportResults, appId, baseId, pageKeys, jsonSchema, targetDefinition, ui5Version) {
    const sectionIds = [];
    const entity = pageKey.split('|')[1];
    for (const section of configSections) {
        const id = findAvailableId(sectionIds, [section.relativePosition, entity, section.relatedFacet].join('|'));
        sectionIds.push(id);
    }
    for (const index in sectionIds) {
        const definition = targetDefinition['anyOf'].find((element) => element.$ref.includes(configSections[index].constructor.name));
        const definitionArray = definition.$ref.split('#/definitions/');
        const nextTargetDefinition = jsonSchema['definitions'][definitionArray[definitionArray.length - 1]];
        transferManifestEntriesAndFlexChange(fullManifest, configSections[index], parentIds, manifest, [...breadcrumbs, sectionIds[index]], exportResults, appId, baseId, pageKeys, jsonSchema, nextTargetDefinition, ui5Version);
    }
    // Delete removed manifest entries
    const manifestSections = manifest_1.getManifestSectionByPathV2(exportResults.manifest, application_1.getViewExtensionsPath());
    for (const key in manifestSections) {
        if (utils_2.isAssociatedCustomSection(key, entity) && !sectionIds.includes(key)) {
            delete manifestSections[key];
        }
    }
}
/**
 * Method returns converted section id by resolving passed section id and title from schema.
 * @param {string[]} breadcrumbs Array of properties that we are currently processing. Required for instance for table column name.
 * @param {string} title Title from JSON schema, comprising the facet ID
 * @returns {string | undefined} Resolved section id.
 */
function getSectionId(breadcrumbs, title) {
    let sectionId = undefined;
    for (let i = breadcrumbs.length - 1; i >= 0; i--) {
        if (breadcrumbs[i] === 'table') {
            sectionId = breadcrumbs[i - 1];
            break;
        }
    }
    return control_1.convertSectionId(sectionId, title);
}
/**
 * Recursive function that traverses the content of the current object. It reads decorators and fills manifest entries and flex changes
 * @param configObject - current (sub)object of the configuration file
 * @param parentIds - array of collected parent ids
 * @param manifest - app descriptor (manifest.json)
 * @param breadcrumbs - array of properties that we are currently processing. Required for instance for table column name
 * @param exportResults - object with all collected manifest entries and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param baseId - selector id of the current page
 * @param pageKeys - array of keys to identify component in manifest
 * @param jsonSchema - application specific schema
 * @param schemaDefinition - the current entry point or definition in the app schema
 * @param title - title from the app schema (comprising for instance the facet ID)
 */
function transferManifestEntriesAndFlexChange(fullManifest, configObject, parentIds, manifest, breadcrumbs, exportResults, appId, baseId, pageKeys, jsonSchema, schemaDefinition, ui5Version, title, logger) {
    let manifestSection, currentConfigObject;
    if (schemaDefinition && schemaDefinition['properties']) {
        for (const key in schemaDefinition['properties']) {
            currentConfigObject = configObject[key];
            const childId = decorators_1.getChildId(configObject, key);
            const ids = childId ? [...parentIds, childId] : parentIds;
            const syncRule = decorators_1.getReflectMetadata(configObject, key);
            if (syncRule) {
                evaluateExportRule(syncRule, configObject, breadcrumbs, baseId, ids, title, key, exportResults, fullManifest, pageKeys, manifestSection, ui5Version);
                continue;
            }
            const propertyDefinition = schemaDefinition['properties'][key];
            if (typeof currentConfigObject === 'object' && propertyDefinition) {
                if (key === 'keyPerformanceIndicators') {
                    Object.keys(currentConfigObject).forEach((newKey) => {
                        currentConfigObject[newKey] = Object.assign(new AnalyticalListPageKPI_1.KPISettings(), currentConfigObject[newKey]);
                        transferManifestEntriesAndFlexChange(fullManifest, currentConfigObject[newKey], ids, manifest, [...breadcrumbs, key], exportResults, appId, baseId, pageKeys, jsonSchema, jsonSchema['definitions']['KPISettings'], ui5Version, newKey, logger);
                    });
                }
                else {
                    let definitionArray = [];
                    if (propertyDefinition.$ref) {
                        definitionArray = propertyDefinition.$ref.split('#/definitions/');
                    }
                    else if (propertyDefinition['anyOf']) {
                        propertyDefinition['anyOf'].forEach((element) => {
                            if (element.$ref.includes(currentConfigObject.constructor.name)) {
                                definitionArray.push(...element.$ref.split('#/definitions/'));
                            }
                        });
                        if (definitionArray.length === 0) {
                            definitionArray = propertyDefinition['anyOf'][0].$ref.split('#/definitions/');
                        }
                    }
                    else if (propertyDefinition.type === 'array' &&
                        (breadcrumbs[0] === 'sections' || breadcrumbs[0] === 'subsections') &&
                        key === 'custom') {
                        transferManifestExtensions(configObject[key], pageKeys[pageKeys.length - 1], fullManifest, ids, manifest, [...breadcrumbs, key], exportResults, appId, baseId, pageKeys, jsonSchema, propertyDefinition.items, ui5Version);
                        continue;
                    }
                    const nextDefinition = utils_1.getNextTargetDefinition(definitionArray, jsonSchema, title, currentConfigObject, propertyDefinition, key);
                    if (Array.isArray(nextDefinition.configObject) && key === 'custom') {
                        let objectPageSectionData;
                        const target = utils_2.getTargetFromCustomColumnRef(propertyDefinition.$ref);
                        if (target) {
                            objectPageSectionData = {
                                target,
                                key: getSectionId(breadcrumbs, title)
                            };
                        }
                        transferColumnExtensions(configObject.custom, exportResults, appId, nextDefinition.targetDefinition, logger, manifest, objectPageSectionData);
                        continue;
                    }
                    else {
                        transferManifestEntriesAndFlexChange(fullManifest, nextDefinition.configObject, ids, manifest, [...breadcrumbs, key], exportResults, appId, baseId, pageKeys, jsonSchema, nextDefinition.targetDefinition, ui5Version, nextDefinition.title, logger);
                    }
                }
            }
            else if (propertyDefinition && propertyDefinition.$ref === '#/definitions/TableCustomColumns') {
                //empty config ==> delete all given extensions
                transferColumnExtensions([], exportResults, appId, jsonSchema['definitions']['TableCustomColumn'], logger, manifest);
                continue;
            }
        }
    }
}
/**
 * Instantiates the relevant object classes for the export of table columns.
 * Common function for LR + ALP
 * @param listReport - list report or ALP config (instantiation of table columns is the same for both)
 * @param complexIdMatch - regex for machting column IDs, diferent for LR + ALP
 */
function instantiateTableColumns(listReport, complexIdMatch) {
    if (listReport.table.columns) {
        for (let columnId in listReport.table.columns) {
            if (complexIdMatch.exec(columnId) !== null) {
                //This part was stripped off during import (table.ts)
                columnId = 'template:::TableColumn:::' + columnId;
            }
            if (columnId === 'custom') {
                const extensionsKeys = Object.keys(listReport.table.columns[columnId]);
                extensionsKeys.forEach((extensionKey) => {
                    listReport.table.columns[columnId][extensionKey] = Object.assign(new controls_1.TableCustomColumn(), listReport.table.columns[columnId][extensionKey]);
                });
            }
            else {
                listReport.table.columns[columnId] = Object.assign(new controls_1.TableColumn(), listReport.table.columns[columnId]);
            }
        }
    }
}
/**
 * Run through the given ListReport config and return respective manifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param page - page definition and configuration file content
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @param ui5Version - SAP UI5 version
 * @param fragments - list of all extension fragment files and their content
 * @param logger - Logger class for logging messages
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
function exportListReportPage(appId, page, manifest, jsonSchema, ui5Version, fragments, logger) {
    const listReportConfig = page.config;
    const entitySet = page.entitySet;
    const exportResults = getDefaultExportResult(fragments);
    // when assigning a JSON structure to an object structure we need to assign all children, otherwise decorators will not exist
    const listReport = Object.assign(new pages_1.ListReport(), listReportConfig);
    if (!listReport.table) {
        listReport.table = Object.assign(new controls_1.ResponsiveTable(), listReport.table);
    }
    if (listReport.table) {
        switch (listReport.table.type) {
            case v2_1.TableTypeV2.ResponsiveTable:
                listReport.table = Object.assign(new controls_1.ResponsiveTable(), listReport.table);
                break;
            case v2_1.TableTypeV2.TreeTable:
                listReport.table = Object.assign(new controls_1.TreeTable(), listReport.table);
                break;
            case v2_1.TableTypeV2.AnalyticalTable:
                listReport.table = Object.assign(new controls_1.AnalyticalTable(), listReport.table);
                break;
            case v2_1.TableTypeV2.GridTable:
                listReport.table = Object.assign(new controls_1.GridTable(), listReport.table);
                break;
            default:
                listReport.table = Object.assign(new controls_1.ResponsiveTable(), listReport.table);
                break;
        }
        const complexIdMatch = new RegExp('DataField.+:::sSmartTableId::listReport.+');
        instantiateTableColumns(listReport, complexIdMatch);
    }
    listReport.filterBar = Object.assign(new controls_1.FilterBar(), listReport.filterBar);
    const pageLayoutInformation = decorators_1.getPageLayoutInformation(listReport);
    const baseId = `${appId}::${pageLayoutInformation.id}::${entitySet}--`;
    const pageKeys = [];
    const v2Page = utils_2.findListReportPage(manifest['sap.ui.generic.app'].pages, pageKeys);
    if (!v2Page.component.settings) {
        v2Page.component.settings = {};
    }
    exportResults.manifest = JSON.parse(JSON.stringify(manifest));
    if (listReportConfig && Object.keys(listReportConfig).length !== 0) {
        transferManifestEntriesAndFlexChange(exportResults.manifest, listReport, [], v2Page, [], exportResults, appId, baseId, pageKeys, jsonSchema, jsonSchema, //starting point for target definition
        ui5Version, undefined, //title
        logger);
    }
    return exportResults;
}
/**
 * Run through the given AnalyticalListPage config and return respective manifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param page - page definition and configuration file content
 * @param entitySet - name of the entity set
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @param ui5Version - SAP UI5 version
 * @param fragments - list of all extension fragment files and their content
 * @param logger - Logger class for logging messages
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
function exportAnalyticalListPage(appId, page, manifest, jsonSchema, ui5Version, fragments, logger) {
    const analyticalListPageConfig = page.config;
    const entitySet = page.entitySet;
    const exportResults = getDefaultExportResult(fragments);
    exportResults.flexChanges = [];
    exportResults.manifest = JSON.parse(JSON.stringify(manifest));
    //Instantiate Page
    const analyticalListPage = Object.assign(new pages_1.AnalyticalListPage(), analyticalListPageConfig);
    //Instantiate Table and columns
    analyticalListPage.table = Object.assign(new controls_1.AnalyticalTable(), analyticalListPage.table);
    const complexIdMatch = new RegExp('DataField.+:::sSmartTableId::analyticalListPage.+');
    instantiateTableColumns(analyticalListPage, complexIdMatch);
    //Instantiate Filterbar
    analyticalListPage.filterBar = Object.assign(new controls_1.AnalyticalListPageFilterBar(), analyticalListPage.filterBar);
    //Instantiate Layout
    const pageLayoutInformation = decorators_1.getPageLayoutInformation(analyticalListPage);
    const baseId = `${appId}::${pageLayoutInformation.id}::${entitySet}--`;
    const pageKeys = [];
    //Instantiate Chart
    analyticalListPage.chart = Object.assign(new AnalyticalListPageChart_1.ChartSettings(), analyticalListPage.chart);
    const v2Page = utils_2.findAnalyticalListPage(manifest['sap.ui.generic.app'].pages, pageKeys);
    v2Page.component.settings = {};
    exportResults.manifest = JSON.parse(JSON.stringify(manifest));
    //Instantiate KPI
    analyticalListPage.keyPerformanceIndicators = Object.assign(new AnalyticalListPageKPI_1.KPISettings(), analyticalListPage.keyPerformanceIndicators);
    if (analyticalListPageConfig && Object.keys(analyticalListPageConfig).length !== 0) {
        transferManifestEntriesAndFlexChange(exportResults.manifest, analyticalListPage, [], v2Page, [], exportResults, appId, baseId, pageKeys, jsonSchema, jsonSchema, //starting point for target definition
        ui5Version, undefined, logger);
    }
    return exportResults;
}
/**
 * Run through the given ObjectPage config and return respective manifest entry and flex changes
 * @param appId - id of the Fiori elements app, which is usually namespace.appid
 * @param page - page definition and configuration file content
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @param ui5Version - SAP UI5 version
 * @param fragments - list of all extension fragment files and their content
 * @param logger - Logger class for logging messages
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
function exportObjectPage(appId, page, manifest, jsonSchema, ui5Version, fragments, logger) {
    const objectPageConfig = page.config;
    const entitySet = page.entitySet;
    const exportResults = getDefaultExportResult(fragments);
    const objectPage = Object.assign(new pages_1.ObjectPage(), objectPageConfig);
    // when assigning a JSON structure to an object structure we need to assign all children, otherwise decorators will not exist
    // find a better way to do this generically, perhaps using the schema?
    if (objectPageConfig) {
        objectPage['header'] = Object.assign(new controls_1.ObjectPageHeader(), objectPage['header']);
        objectPage.header.actions = Object.assign(new controls_1.ObjectPageHeader(), objectPage.header.actions);
        for (const headerId in objectPageConfig.header) {
            if (headerId === 'actions') {
                for (const actionId in objectPageConfig.header.actions) {
                    const action = objectPage.header.actions;
                    action[actionId] = Object.assign(new ObjectPageHeaderAction_1.HeaderAction(), action[actionId]);
                }
            }
        }
        objectPage.layout = Object.assign(new controls_1.ObjectPageLayout(), objectPage.layout);
        const pageLayoutInformation = decorators_1.getPageLayoutInformation(objectPage);
        const baseId = `${appId}::${pageLayoutInformation.id}::${entitySet}--`;
        exportResults.manifest = JSON.parse(JSON.stringify(manifest));
        const pageKeys = [];
        const v2Page = utils_2.findObjectPage(manifest['sap.ui.generic.app'].pages, entitySet, pageKeys);
        if (!v2Page) {
            return exportResults;
        }
        if (!v2Page.component.settings) {
            v2Page.component.settings = {};
        }
        if (objectPageConfig && objectPageConfig.sections) {
            getExportClassesForSections(objectPageConfig, objectPage, v2Page);
        }
        if (objectPageConfig && Object.keys(objectPageConfig).length !== 0) {
            transferManifestEntriesAndFlexChange(exportResults.manifest, objectPage, [], v2Page, [], exportResults, appId, baseId, pageKeys, jsonSchema, jsonSchema, //starting point for target definition
            ui5Version, undefined, logger);
        }
        return exportResults;
    }
    else {
        exportResults.manifest = JSON.parse(JSON.stringify(manifest));
        return exportResults;
    }
}
/**
 * Run through the given ObjectPage config and return respective manifest entry and flex changes
 * @param overviewPageConfig - content of the src/OverviewPage_<entity_set>.json file
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
const exportOverviewPage = (overviewPageConfig, manifest, jsonSchema) => {
    const exportResults = getDefaultExportResult();
    const overviewPage = Object.assign(new pages_1.OverviewPage(), overviewPageConfig);
    overviewPage.cards = Object.assign(new controls_1.CustomCard(), overviewPage.cards);
    exportResults.manifest = JSON.parse(JSON.stringify(manifest));
    if (overviewPageConfig && Object.keys(overviewPageConfig).length !== 0) {
        transferManifestEntriesOVP(overviewPage, exportResults.manifest, exportResults, jsonSchema, jsonSchema, []);
    }
    return exportResults;
};
/**
 * Exports a Fiori Element V2 application.
 * It converts the entries of the input application (config file) to corresponding manifest settings and flex changes
 * @param application - content of the config file of an application
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
const exportApplicationV2 = (application, manifest, jsonSchema) => {
    const exportResults = getDefaultExportResult();
    exportResults.manifest = JSON.parse(JSON.stringify(manifest));
    //transfer application settings
    const applicationV2 = Object.assign(new application_1.ApplicationV2(), application);
    applicationV2.settings = Object.assign(new application_1.AppSettings(), application['settings']);
    for (const key in jsonSchema['definitions']['AppSettings']['properties']) {
        const syncRule = decorators_1.getReflectMetadata(applicationV2.settings, key);
        if (syncRule && syncRule.manifest) {
            const path = syncRule.manifest.path();
            const manifestSection = manifest_1.getManifestSectionByPathV2(exportResults.manifest, path);
            if (application['settings'] && application['settings'][key] !== undefined) {
                manifestSection[key] = application['settings'][key];
            }
            else {
                delete manifestSection[key];
            }
        }
    }
    // transfer pages and routings
    const manifestPages = exportResults.manifest['sap.ui.generic.app'] && exportResults.manifest['sap.ui.generic.app'].pages;
    if (manifestPages && application['pages']) {
        manifest_1.transformPageToNewManifestV2(application.home, application['pages'], Object.values(manifestPages)[0]);
    }
    return exportResults;
};
/**
 * Exports a Fiori Element V2 page.
 * It converts the entries of the input page (config file) to corresponding manifest settings and flex changes
 * @param appId - application id
 * @param page - content of the config file of a page
 * @param manifest - app descriptor (manifest.json)
 * @param jsonSchema - application specific schema
 * @param entityAnnotations - list of annotations of the entity type that the page is referring to
 * @returns ExportResults - The export result comprises the enhanced manifest as well as a list of flex changes.
 */
function exportPageV2(exportParametersV2, ui5Version) {
    if (exportParametersV2[common_2.SchemaType.ListReport]) {
        const { appId, page, manifest, jsonSchema, fragments, logger } = exportParametersV2[common_2.SchemaType.ListReport];
        return exportListReportPage(appId, page, manifest, jsonSchema, ui5Version, fragments, logger);
    }
    else if (exportParametersV2[common_2.SchemaType.ObjectPage]) {
        const { appId, page, manifest, jsonSchema, fragments, logger } = exportParametersV2[common_2.SchemaType.ObjectPage];
        return exportObjectPage(appId, page, manifest, jsonSchema, ui5Version, fragments, logger);
    }
    else if (exportParametersV2[common_2.SchemaType.OverviewPage]) {
        const { page, manifest, jsonSchema } = exportParametersV2[common_2.SchemaType.OverviewPage];
        return exportOverviewPage(page.config, manifest, jsonSchema);
    }
    else if (exportParametersV2[common_2.SchemaType.Application]) {
        const { application, manifest, jsonSchema } = exportParametersV2[common_2.SchemaType.Application];
        return exportApplicationV2(application, manifest, jsonSchema);
    }
    else if (exportParametersV2[common_2.SchemaType.AnalyticalListPage]) {
        const { appId, page, manifest, jsonSchema, fragments, logger } = exportParametersV2[common_2.SchemaType.AnalyticalListPage];
        return exportAnalyticalListPage(appId, page, manifest, jsonSchema, ui5Version, fragments, logger);
    }
}
exports.exportPageV2 = exportPageV2;
//# sourceMappingURL=export.js.map
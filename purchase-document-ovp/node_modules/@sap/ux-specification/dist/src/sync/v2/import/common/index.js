"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const page_1 = require("../../../../specification/common/page");
const table_1 = require("../controls/table");
const common_1 = require("../../../common");
const decorators_1 = require("../../../common/decoration/decorators");
const manifest_1 = require("../../export/manifest");
const v2_1 = require("../../../../specification/v2");
const extensionLogger_1 = require("../../../../extensionLogger");
const i18next_1 = __importDefault(require("i18next"));
function convertSelector(selectorId) {
    return selectorId
        .replace(/:2f/g, '/')
        .replace(/:23/g, '#')
        .replace(/:40/g, '@');
}
exports.convertSelector = convertSelector;
function addFlex(config, changeString, jsonSchema, logger) {
    try {
        const change = common_1.parseChangeString(changeString);
        const changePropertyKey = change.content.property;
        if (change.controlId.includes(page_1.PageType.ListReport) || change.controlId.includes(page_1.PageType.AnalyticalListPage)) {
            change.controlId = convertSelector(change.controlId);
            if (change.controlType === common_1.ControlType.SmartFilterBar) {
                const schemaProperty = jsonSchema['definitions']['FilterBar'].properties[changePropertyKey];
                if (schemaProperty) {
                    config.filterBar[changePropertyKey] = change.content.newBinding
                        ? change.content.newBinding
                        : change.content.newValue;
                }
            }
            else if (change.controlType === common_1.ControlType.DynamicPage) {
                config[change.content.property] = change.content.newValue;
            }
            else if (change.controlType === common_1.ControlType.SmartChart) {
                const schemaProperty = jsonSchema['definitions']['ChartSettings'].properties[changePropertyKey];
                if (schemaProperty) {
                    config['chart'][changePropertyKey] = change.content.newBinding
                        ? change.content.newBinding
                        : change.content.newValue;
                }
            }
            else {
                const flexForTransfer = {
                    controlId: change.controlId,
                    propertyId: change.content.property,
                    newValue: change.content.newBinding ? change.content.newBinding : change.content.newValue,
                    controlType: change.controlType
                };
                table_1.addFlexForTable(config.table, flexForTransfer);
            }
        }
    }
    catch (error) {
        extensionLogger_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('FLEXERROR')
        }, ...error);
    }
}
exports.addFlex = addFlex;
function transferSettingsOfObject(configPart, manifest, jsonSchema, pageKey, logger, kpiKey) {
    if (!jsonSchema) {
        return;
    }
    let deprecatedProperties = [];
    let manifestSection = {};
    if (configPart.getDeprecated) {
        deprecatedProperties = configPart.getDeprecated();
    }
    if (jsonSchema['properties']) {
        for (const propertyKey in jsonSchema['properties']) {
            const syncRule = decorators_1.getReflectMetadata(configPart, propertyKey);
            // Version check
            if (syncRule && syncRule.manifest) {
                const path = syncRule.manifest.path([pageKey], undefined, kpiKey);
                manifestSection = manifest_1.getManifestSectionByPathV2(manifest, path);
                const manifestKey = syncRule.manifest.key || propertyKey;
                if (manifestSection[manifestKey] !== undefined) {
                    const importHandler = syncRule.manifest.import;
                    if (importHandler && typeof importHandler === 'function') {
                        const value = importHandler(manifestSection[manifestKey]);
                        if (value !== undefined) {
                            configPart[propertyKey] = value;
                        }
                    }
                    else {
                        configPart[manifestKey] = manifestSection[propertyKey];
                    }
                }
                // Check for deprecated properties.
                if (manifestSection && deprecatedProperties) {
                    for (const key in manifestSection) {
                        const deprecated = deprecatedProperties[key];
                        if (deprecated) {
                            extensionLogger_1.log(logger, {
                                severity: "warning" /* Warning */,
                                message: decorators_1.getTextForDeprecated(key, deprecated),
                                location: {
                                    path: 'webapp/manifest.json/',
                                    range: path.split('/')
                                }
                            });
                            delete deprecatedProperties[key];
                        }
                    }
                }
            }
            // Adjustment of 'quickVariantSelectionX' - tableSettings
            if (propertyKey === 'quickVariantSelectionX' && configPart[propertyKey]) {
                for (const variant in configPart[propertyKey]['variants']) {
                    const currentQuickVariantX = configPart[propertyKey]['variants'][variant];
                    if (currentQuickVariantX['tableSettings']) {
                        for (const key in currentQuickVariantX['tableSettings']) {
                            currentQuickVariantX[key] = currentQuickVariantX['tableSettings'][key];
                        }
                        delete currentQuickVariantX['tableSettings'];
                    }
                }
            }
        }
    }
}
exports.transferSettingsOfObject = transferSettingsOfObject;
/**
 * Determines the table type for a given LR or ALP table, based on the component name and its table settings
 * @param manifest - manifest.json file content of the app
 * @param pageKey - key of the page in the manifest
 */
function determineTableType(manifest, pageKey) {
    const page = manifest['sap.ui.generic.app'].pages[pageKey];
    let tableType = v2_1.TableTypeV2.ResponsiveTable;
    if (page.component.name === 'sap.suite.ui.generic.template.AnalyticalListPage') {
        tableType = v2_1.TableTypeV2.AnalyticalTable;
    }
    else if (manifest['sap.ui.generic.app'].pages[pageKey].component.settings &&
        manifest['sap.ui.generic.app'].pages[pageKey].component.settings.tableSettings &&
        manifest['sap.ui.generic.app'].pages[pageKey].component.settings.tableSettings['type']) {
        tableType = page.component.settings.tableSettings['type'];
    }
    return tableType;
}
exports.determineTableType = determineTableType;
//# sourceMappingURL=index.js.map
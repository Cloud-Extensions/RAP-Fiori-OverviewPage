"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const annotation_converter_1 = require("@sap-ux/annotation-converter");
const edmx_parser_1 = require("@sap-ux/edmx-parser");
const common_1 = require("../../specification/common");
const schemaAccess_1 = require("../../specification/schemaAccess");
const fs = __importStar(require("fs"));
const i18next_1 = __importDefault(require("i18next"));
const extensionLogger_1 = require("../../extensionLogger");
var TemplateType;
(function (TemplateType) {
    TemplateType["ListReportObjectPageV2"] = "ListReportObjectPageV2";
    TemplateType["ListReportObjectPageV4"] = "ListReportObjectPageV4";
    TemplateType["FormPageV4"] = "FormPageV4";
    TemplateType["OverviewPageV2"] = "OverviewPageV2";
    TemplateType["AnalyticalListPageV2"] = "AnalyticalListPageV2";
    TemplateType["AnalyticalListPageV4"] = "AnalyticalListPageV4";
})(TemplateType = exports.TemplateType || (exports.TemplateType = {}));
async function readFile(path) {
    return new Promise((resolve, reject) => {
        fs.readFile(path, { encoding: 'utf8' }, (err, data) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(data);
            }
        });
    });
}
exports.readFile = readFile;
/**
 * Parses, merges, and converts a list of annotation files with aid of tools from annotation-vocabularies-tools
 * @param annotationFiles - The list of all annotation files, in JSON format
 * @returns the complete service information
 */
function parseAndMergeAndConvert(annotationFiles, logger) {
    const parseResult = [];
    try {
        if (annotationFiles) {
            annotationFiles.forEach(function (annotationData) {
                parseResult.push(edmx_parser_1.parseEDMX(annotationData.fileContent, annotationData.dataSourceUri));
            });
        }
        if (parseResult.length === 0) {
            return;
        }
        const converterOutput = annotation_converter_1.convertTypes(edmx_parser_1.merge(parseResult));
        if (logger && converterOutput.diagnostics) {
            for (let index = 0; index < converterOutput.diagnostics.length; index++) {
                const converterMessage = converterOutput.diagnostics[index];
                extensionLogger_1.log(logger, {
                    severity: "error" /* Error */,
                    message: converterMessage.message
                });
            }
        }
        return converterOutput;
    }
    catch (error) {
        extensionLogger_1.log(logger, {
            severity: "error" /* Error */,
            message: i18next_1.default.t('ANNOERR')
        }, ...error);
    }
}
exports.parseAndMergeAndConvert = parseAndMergeAndConvert;
exports.getAnnotationPropertyValue = (annotationProperty) => annotationProperty.value || annotationProperty.path;
/**
 * Common function determining the label for a LineItem record
 * @param {DataFieldAbstractType} lineItemRecord - Line item record
 * @param {EntityType} entityType - Entity type
 */
function getCommonLabel(lineItemRecord, entityType) {
    let label, property;
    if (lineItemRecord['Value']) {
        if (typeof lineItemRecord['Value'] === 'string') {
            property = entityType.entityProperties.find((ep) => ep.name === lineItemRecord['Value']);
        }
        else {
            property = entityType.entityProperties.find((ep) => ep.name === lineItemRecord['Value'].path);
            if (!property) {
                property = lineItemRecord['Value'].$target;
            }
        }
    }
    else if (lineItemRecord['Target'] && lineItemRecord['Target'].$target && lineItemRecord['Target'].$target.Value) {
        property = lineItemRecord['Target'].$target.Value.$target;
    }
    if (property && property.annotations && property.annotations.Common && property.annotations.Common.Label) {
        label = property.annotations.Common.Label.toString();
    }
    return label;
}
/**
 * Determines the description of a column header
 * @param lineItemRecord - the given record of the line item annotation
 * @param entityType - the entity type as part of the AVT ConverterOutput
 */
function getColumnDescription(lineItemRecord, entityType) {
    let title = '', propertyCommonLabel;
    switch (lineItemRecord.$Type) {
        case "com.sap.vocabularies.UI.v1.DataField" /* DataField */:
            propertyCommonLabel = getCommonLabel(lineItemRecord, entityType);
            title =
                lineItemRecord.Label ||
                    propertyCommonLabel ||
                    (lineItemRecord.Value.$target
                        ? lineItemRecord.Value.$target.name
                        : lineItemRecord.Value.value || lineItemRecord.Value.path);
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithUrl" /* DataFieldWithUrl */:
            propertyCommonLabel = getCommonLabel(lineItemRecord, entityType);
            title =
                lineItemRecord.Label ||
                    propertyCommonLabel ||
                    (typeof lineItemRecord.Value === 'string' ? lineItemRecord.Value : lineItemRecord.Value.path);
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForAnnotation" /* DataFieldForAnnotation */:
            propertyCommonLabel = getCommonLabel(lineItemRecord, entityType);
            title =
                lineItemRecord.Label ||
                    propertyCommonLabel ||
                    lineItemRecord.Target.$target.Title ||
                    lineItemRecord.Target.value;
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */:
        case "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* DataFieldForIntentBasedNavigation */:
            if (lineItemRecord.Label) {
                title =
                    typeof lineItemRecord.Label === 'string' ? lineItemRecord.Label : lineItemRecord.Action;
            }
            else {
                title = lineItemRecord.Action;
            }
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithIntentBasedNavigation" /* DataFieldWithIntentBasedNavigation */:
            propertyCommonLabel = getCommonLabel(lineItemRecord, entityType);
            title = propertyCommonLabel || lineItemRecord.Value.path;
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath" /* DataFieldWithNavigationPath */:
            propertyCommonLabel = getCommonLabel(lineItemRecord, entityType);
            title =
                lineItemRecord.Label ||
                    propertyCommonLabel ||
                    (lineItemRecord.Value.$target
                        ? lineItemRecord.Value.$target.name
                        : lineItemRecord.Value.value || lineItemRecord.Value.path);
            break;
        default:
            break;
    }
    return title;
}
exports.getColumnDescription = getColumnDescription;
/**
 * Return the page type for a given V2 page in manifest
 * @param name - page component name
 */
function getPageTypeV2(name) {
    if (name) {
        return name.split('sap.suite.ui.generic.template.')[1];
    }
}
exports.getPageTypeV2 = getPageTypeV2;
/**
 * Return the page type for a given V4 page in manifest
 * @param name - page component name
 */
function getPageTypeV4(name) {
    if (name) {
        return name.split('sap.fe.templates.')[1];
    }
}
exports.getPageTypeV4 = getPageTypeV4;
/**
 * Resolve page section(get key and label->description).
 * @param facetDefinition - the actual annotation record
 * @param keyForRelatedFacetKeys - construct key for 'keyForRelatedFacetKeys' property(used to define custom sections) - we should not add '@' symbol there.
 * @returns {FacetSection} - object comprising the relevant facet information
 */
function getSectionFacet(facetDefinition, keyForRelatedFacetKeys = false, oDataVersion = common_1.FioriElementsVersion.v2) {
    const entityName = facetDefinition.fullyQualifiedName.substr(facetDefinition.fullyQualifiedName.lastIndexOf('@'));
    //Take facet ID as fallback
    let key = facetDefinition.ID ? facetDefinition.ID.toString() : entityName;
    //If reference facet: overwrite with target annotation if present
    if (facetDefinition.$Type !== 'com.sap.vocabularies.UI.v1.CollectionFacet' && 'Target' in facetDefinition) {
        const propertyValue = exports.getAnnotationPropertyValue(facetDefinition.Target);
        const navSeparator = oDataVersion === common_1.FioriElementsVersion.v2 ? '::' : '/';
        const separator = oDataVersion === common_1.FioriElementsVersion.v2 ? '::' : '#';
        const navigationParts = propertyValue.split('/');
        const navigation = navigationParts.length > 1 ? navigationParts[0] : '';
        const uiParts = (navigationParts[1] || navigationParts[0]).split('#');
        const uiClass = uiParts[0];
        const qualifier = uiParts[1] || '';
        if (uiClass.includes('.LineItem')) {
            const pathParts = key.split('::');
            pathParts[pathParts.length - 1] = `${!keyForRelatedFacetKeys ? '@' : ''}com.sap.vocabularies.UI.v1.LineItem`;
            key = pathParts.join('::');
        }
        else {
            key = uiClass.replace('@UI', `${!keyForRelatedFacetKeys ? '@' : ''}com.sap.vocabularies.UI.v1`);
        }
        if (navigation) {
            key = `${navigation}${navSeparator}${key}`;
        }
        if (qualifier) {
            key = `${key}${separator}${qualifier}`;
        }
    }
    key = key.replace(/\//gi, '::');
    return key
        ? Object.assign(Object.assign({ key }, (facetDefinition.Label && { label: facetDefinition.Label.toString() })), (facetDefinition.ID && { ID: facetDefinition.ID.toString() })) : undefined;
}
exports.getSectionFacet = getSectionFacet;
exports.getManifestSectionByPathV4 = (exportResultManifest, path, targetAnnotation, targetAnnotationEncoded) => {
    let exportResultSection = exportResultManifest;
    path.split('/').forEach(function (element) {
        if (targetAnnotationEncoded && targetAnnotationEncoded === element) {
            element = targetAnnotation;
        }
        if (!exportResultSection[element]) {
            exportResultSection[element] = {};
        }
        exportResultSection = exportResultSection[element];
    });
    return exportResultSection;
};
/**
 * Finds the alias for a given namespace in the references' section of the converted service metadata
 * @param {string} namespace - complete namespace, e.g. 'com.sap.vocabularies.UI.v1'
 * @param {ConverterOutput} oDataServiceAVT - combined service metadata, as returned by annotation vocabularies tools
 * @returns alias for the given namespace
 */
function findAlias(namespace, oDataServiceAVT) {
    const aliasReference = oDataServiceAVT.references.find((reference) => {
        return reference.namespace === namespace;
    });
    return aliasReference && aliasReference.alias;
}
exports.findAlias = findAlias;
function getSchemaKeyOfLineItemRecord(lineItemRecord) {
    let schemaKey, target, value;
    switch (lineItemRecord.$Type) {
        case "com.sap.vocabularies.UI.v1.DataField" /* DataField */:
            schemaKey = exports.getAnnotationPropertyValue(lineItemRecord.Value);
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithUrl" /* DataFieldWithUrl */:
            schemaKey =
                typeof lineItemRecord.Value === 'string'
                    ? lineItemRecord.Value
                    : exports.getAnnotationPropertyValue(lineItemRecord.Value);
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForAnnotation" /* DataFieldForAnnotation */:
            target = lineItemRecord.Target.value;
            schemaKey =
                'DataFieldForAnnotation:::sTarget::' +
                    target
                        .replace('@UI', '@com.sap.vocabularies.UI.v1')
                        .replace('@Communication', '@com.sap.vocabularies.Communication.v1')
                        .replace('@Contact', '@com.sap.vocabularies.Contact.v1');
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForAction" /* DataFieldForAction */:
            if (lineItemRecord.Inline) {
                schemaKey = 'DataFieldForAction:::sAction::' + lineItemRecord.Action;
            }
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithIntentBasedNavigation" /* DataFieldWithIntentBasedNavigation */:
            value = exports.getAnnotationPropertyValue(lineItemRecord.Value);
            schemaKey =
                'DataFieldWithIntentBasedNavigation:::sProperty::' +
                    value +
                    ':::sSemanticObject::' +
                    lineItemRecord.SemanticObject +
                    ':::sAction::' +
                    lineItemRecord.Action;
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldForIntentBasedNavigation" /* DataFieldForIntentBasedNavigation */:
            if (lineItemRecord.Inline) {
                schemaKey =
                    'DataFieldForIntentBasedNavigation:::sSemanticObject::' +
                        lineItemRecord.SemanticObject +
                        ':::sAction::' +
                        lineItemRecord.Action;
            }
            break;
        case "com.sap.vocabularies.UI.v1.DataFieldWithNavigationPath" /* DataFieldWithNavigationPath */:
            value = exports.getAnnotationPropertyValue(lineItemRecord.Value);
            target = exports.getAnnotationPropertyValue(lineItemRecord.Target);
            schemaKey = 'DataFieldWithNavigationPath:::sProperty::' + value + ':::sTarget::' + target;
            break;
        default:
            break;
    }
    return schemaKey;
}
exports.getSchemaKeyOfLineItemRecord = getSchemaKeyOfLineItemRecord;
/**
 * Evaluates the target annotation of a reference facet and actualizes the facets for the config
 * @param {AnnotationTerm} annotationRecord - the actual annotation record
 * @param {FacetConfigs} facets - list of facets in config format, to be updated
 * @param {string} serviceName - name of the service of the app
 * @param {string} entityName - the entity (type) name
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 */
function evaluateTargetAnnotation(annotationRecord, facets, serviceName, entityName, oDataServiceAVT, oDataVersion = common_1.FioriElementsVersion.v2) {
    const section = getSectionFacet(annotationRecord, false, oDataVersion);
    let path = section.key;
    const alias = findAlias('com.sap.vocabularies.UI.v1', oDataServiceAVT);
    if (path.includes('com.sap.vocabularies.UI.v1.Chart') || path.includes(alias + '.Chart')) {
        facets[path] = { base: 'ChartFacet' };
    }
    else if (path.includes('com.sap.vocabularies.UI.v1.LineItem') || path.includes(alias + '.LineItem')) {
        const entityType = oDataServiceAVT.entityTypes.find((e) => e.fullyQualifiedName === `${serviceName}.${entityName}`);
        if (entityType) {
            const navPath = path.substr(0, path.lastIndexOf('::'));
            const navProp = entityType.navigationProperties.find((n) => n.name === navPath);
            const targetEntity = navProp && navProp['targetType'].fullyQualifiedName;
            let scope, version, annotation;
            if (path.includes('com.sap.vocabularies.UI.v1.LineItem')) {
                [scope, version, annotation] = path.split('com.sap.vocabularies.')[1].split('.');
            }
            else if (path.includes('.LineItem')) {
                scope = alias;
                annotation = 'LineItem';
                const pathParts = path.split('::');
                pathParts[pathParts.length - 1] = '@com.sap.vocabularies.UI.v1.LineItem';
                path = pathParts.join('::');
            }
            facets[path] = { base: 'LineItemFacet' };
            const targetEntityType = oDataServiceAVT.entityTypes.find((et) => et.fullyQualifiedName === targetEntity);
            if (targetEntityType &&
                targetEntityType.annotations &&
                targetEntityType.annotations[scope] &&
                targetEntityType.annotations[scope][annotation]) {
                facets[path]['lineItem'] = targetEntityType.annotations[scope][annotation];
                facets[path]['entityType'] = targetEntityType;
            }
        }
    }
    else if (path.includes('com.sap.vocabularies.UI.v1.FieldGroup') || path.includes(alias + '.FieldGroup')) {
        facets[path] = { base: 'FormFacet' };
    }
    else {
        facets[path] = { base: '' };
    }
    if (annotationRecord.Label) {
        facets[path].Label = annotationRecord.Label;
    }
    // Add Facet ID
    if (annotationRecord.ID) {
        facets[path]['ID'] = annotationRecord.ID;
    }
}
/**
 * Adds the information from facets to the config
 * @param {AnnotationTerm} annotationRecord - the actual annotation record
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {string} serviceName - name of the service of the app
 * @param {string} entityName - the entity (type) name
 * @param {FacetConfigs} facets - list of facets in config format, to be updated
 */
function addFacetToConfig(annotationRecord, oDataServiceAVT, serviceName, entityName, facets, oDataVersion = common_1.FioriElementsVersion.v2) {
    switch (annotationRecord.$Type) {
        case "com.sap.vocabularies.UI.v1.ReferenceFacet" /* ReferenceFacet */: {
            evaluateTargetAnnotation(annotationRecord, facets, serviceName, entityName, oDataServiceAVT, oDataVersion);
            break;
        }
        case "com.sap.vocabularies.UI.v1.CollectionFacet" /* CollectionFacet */: {
            const section = getSectionFacet(annotationRecord, false, oDataVersion);
            const facet = (facets[section.key] = {
                base: 'CollectionFacet',
                facets: {},
                ID: section.ID
            });
            annotationRecord.Facets.forEach((collectionItem) => {
                addFacetToConfig(collectionItem, oDataServiceAVT, serviceName, entityName, facet.facets, oDataVersion);
            });
            break;
        }
    }
}
/**
 * Retrieve facet configurations that can be used to generate ObjectPage schemas
 * @param {QualifiedName} entityTypeName - the name of the actual entity type
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 * @param {FioriElementsVersion} oDataVersion - OData version
 */
function getObjectPageFacets(entityTypeName, oDataServiceAVT, oDataVersion = common_1.FioriElementsVersion.v2) {
    const facets = {};
    const entityType = oDataServiceAVT.entityTypes.find((et) => et.name === entityTypeName);
    if (!entityType || !entityType.annotations) {
        return;
    }
    const alias = findAlias('com.sap.vocabularies.UI.v1', oDataServiceAVT);
    const facetAnnotation = alias && entityType.annotations[alias] && entityType.annotations[alias].Facets;
    if (facetAnnotation) {
        const lastDot = entityType.fullyQualifiedName.lastIndexOf('.');
        const serviceName = entityType.fullyQualifiedName.substr(0, lastDot);
        // Add facets to configuration
        facetAnnotation.forEach((item) => {
            addFacetToConfig(item, oDataServiceAVT, serviceName, entityTypeName, facets, oDataVersion);
        });
    }
    return facets;
}
exports.getObjectPageFacets = getObjectPageFacets;
/**
 * Returns the version of Fiori elements (v2/v4) from a given manifest
 * @param manifest - the manifest.json file
 */
function getVersionFromManifest(manifest) {
    if (manifest['sap.ui.generic.app'] || manifest['sap.ovp']) {
        return common_1.FioriElementsVersion.v2;
    }
    else {
        return common_1.FioriElementsVersion.v4;
    }
}
exports.getVersionFromManifest = getVersionFromManifest;
function getTemplateTypeFromManifest(manifest, fioriElementsVersion, logger) {
    let templateType;
    if (manifest['sap.ovp']) {
        templateType = TemplateType.OverviewPageV2;
    }
    else if (fioriElementsVersion === common_1.FioriElementsVersion.v2) {
        if (manifest['sap.ui.generic.app']) {
            const v2Pages = manifest['sap.ui.generic.app'].pages;
            if (!v2Pages) {
                extensionLogger_1.log(logger, {
                    severity: "error" /* Error */,
                    message: i18next_1.default.t('NOPAGES', { appId: manifest['sap.app']['id'] }),
                    location: {
                        path: 'webapp/manifest.json',
                        range: ['sap.ui.generic.app']
                    }
                });
                return;
            }
            for (const pageKey in v2Pages) {
                const v2Page = v2Pages[pageKey];
                if (getPageTypeV2(v2Page.component.name) === common_1.PageType.AnalyticalListPage) {
                    templateType = TemplateType.AnalyticalListPageV2;
                    break;
                }
                else if (getPageTypeV2(v2Page.component.name) === common_1.PageType.ListReport) {
                    templateType = TemplateType.ListReportObjectPageV2;
                    break;
                }
            }
        }
        else {
            if (!templateType) {
                extensionLogger_1.log(logger, {
                    severity: "error" /* Error */,
                    message: i18next_1.default.t('NOTEMPLATE', { section: 'sap.ui.generic.app' }),
                    location: {
                        path: 'webapp/manifest.json',
                        range: ['sap.ui.generic.app']
                    }
                });
            }
        }
    }
    else if (fioriElementsVersion === common_1.FioriElementsVersion.v4) {
        const v4Pages = manifest['sap.ui5'].routing && manifest['sap.ui5'].routing.targets;
        if (!v4Pages) {
            extensionLogger_1.log(logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('NOPAGES', { appId: manifest['sap.app']['id'] }),
                location: {
                    path: 'webapp/manifest.json',
                    range: ['sap.ui5', 'routing']
                }
            });
            return;
        }
        for (const pageKey in v4Pages) {
            const v4Page = v4Pages[pageKey];
            if (getPageTypeV4(v4Page.name) === common_1.PageTypeV4.AnalyticalListPage) {
                templateType = TemplateType.AnalyticalListPageV4;
                break;
            }
            else if (getPageTypeV4(v4Page.name) === common_1.PageTypeV4.ListReport) {
                templateType = TemplateType.ListReportObjectPageV4;
                break;
            }
            else if (getPageTypeV4(v4Page.name) === common_1.PageTypeV4.ObjectPage) {
                templateType = TemplateType.FormPageV4;
                break;
            }
        }
        if (!templateType) {
            extensionLogger_1.log(logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('NOTEMPLATE', { section: 'sap.ui5' }),
                location: {
                    path: 'webapp/manifest.json',
                    range: ['sap.ui5', 'routing', 'targets']
                }
            });
        }
    }
    else {
        if (!templateType) {
            extensionLogger_1.log(logger, {
                severity: "error" /* Error */,
                message: i18next_1.default.t('NOFE'),
                location: {
                    path: 'webapp/manifest.json'
                }
            });
        }
    }
    return templateType;
}
exports.getTemplateTypeFromManifest = getTemplateTypeFromManifest;
/**
 * Creates a default object for a new section or subsection, and adds the ID as title if present.
 * @param facet Facet configuration, to be analyzed
 * @returns the new section object
 */
function createSectionWithoutProperties(facet) {
    const section = {
        type: 'object',
        properties: {},
        additionalProperties: false
    };
    if (facet && facet.ID) {
        section['title'] = types_1.FacetTitlePrefix + facet.ID;
    }
    if (facet && facet.Label) {
        section['description'] = facet.Label;
    }
    return section;
}
exports.createSectionWithoutProperties = createSectionWithoutProperties;
/**
 * Retrieve page section data(so far id/key and label/description).
 * @param {QualifiedName} entityTypeName The actual entitySet (corresponds to the given page)
 * @param {ConverterOutput} oDataServiceAVT - complete service information, as returned by annotation vocabularies tool
 */
function getObjectPageFacetSection(entityTypeName, oDataServiceAVT, oDataVersion = common_1.FioriElementsVersion.v2) {
    const entityType = oDataServiceAVT.entityTypes.find((et) => et.name === entityTypeName);
    const alias = findAlias('com.sap.vocabularies.UI.v1', oDataServiceAVT);
    if (entityType) {
        const facetAnnotation = alias && entityType.annotations && entityType.annotations[alias] && entityType.annotations[alias].Facets;
        if (!facetAnnotation) {
            return [];
        }
        return facetAnnotation.reduce(function (result, item) {
            const section = getSectionFacet(item, true, oDataVersion);
            if (section) {
                result.push(section);
            }
            return result;
        }, []);
    }
}
exports.getObjectPageFacetSection = getObjectPageFacetSection;
/**
 * Cleans empty sub-structures from the export result for manifest
 * @param manifest - manifest.json part of the export result
 * @param path  - path in the manifest
 * @param targetAnnotation - target annotation (optional, in case of sections, subsections)
 * @param targetAnnotationEncoded - encoded version of the target annotation, as represented in the manifest
 */
exports.deleteEmptyStructure = (manifest, path, targetAnnotation, targetAnnotationEncoded) => {
    let manifestSection = manifest;
    path.split('/').forEach(function (element) {
        if (element === targetAnnotationEncoded) {
            element = targetAnnotation;
        }
        if (!manifestSection[element]) {
            return;
        }
        if (Object.keys(manifestSection[element]).length === 0) {
            delete manifestSection[element];
            return;
        }
        manifestSection = manifestSection && manifestSection[element];
    });
};
/**
 * Method which returns generic schema file name.
 * @param {SchemaType | PageType} schemaType Schema type or Page type.
 * @return {string} File name of generic schema.
 */
const getGenericSchemaFileName = (schemaType) => {
    return `${schemaType}`;
};
/**
 * Method which returns schema file name and path depending on passed schema or page type.
 * @param {SchemaType | PageType} schemaType Schema type or Page type.
 * @param {string} [entitySet] Entity set string.
 * @return {SchemaFilePath} File path info.
 */
exports.getSchemaFilePath = (schemaType, entitySet) => {
    const schemaFile = {
        filename: '',
        path: ''
    };
    switch (schemaType) {
        // Application schema
        case schemaAccess_1.SchemaType.Application: {
            // File name
            schemaFile.filename = `App`;
            // Full path
            schemaFile.path = `./${types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
        // List report and object page
        case schemaAccess_1.SchemaType.ListReport:
        case schemaAccess_1.SchemaType.ObjectPage: {
            // File name
            schemaFile.filename = entitySet ? `${schemaType}_${entitySet}` : getGenericSchemaFileName(schemaType);
            // Full path
            schemaFile.path = `../${types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
        // Other page configs
        default: {
            // File name
            schemaFile.filename = getGenericSchemaFileName(schemaType);
            // Full path
            schemaFile.path = `../${types_1.DirName.Schemas}/${schemaFile.filename}`;
            break;
        }
    }
    schemaFile.path += '.json';
    return schemaFile;
};
/**
 * Method which generates id of page according to passed parameters.
 * @param appVersion - Fiori Elements version - V2 or V4.
 * @param pageType - Page type.
 * @param entitySet - Entity Set.
 * @param navigationProperty - Navigation property (optional).
 * @param viewId - Custom page's viewId (optional).
 * @returns {string} Generated page id
 */
function generatePageId(pageType, entitySet, navigationProperty, viewId) {
    if (pageType === common_1.PageType.CustomPage) {
        const names = viewId && viewId.split('.');
        return names && names[names.length - 1] + 'Page';
    }
    const parts = [];
    parts.push(pageType);
    if (entitySet) {
        parts.push(entitySet);
    }
    // Page navigation - Optional
    if (navigationProperty) {
        parts.push(navigationProperty);
    }
    return parts.join('_');
}
exports.generatePageId = generatePageId;
/**
 * Recursive function to determine the next config part, next definition in the app schema and the title
 * @param definitionArray - array comprising split parts of the previous definition
 * @param appSchema - app schema
 * @param title - default title
 * @param currentConfigObject - current part of the configuration that gets traversed
 * @param propertyDefinition - definition of a given property in the app schema
 * @param key - actual key
 */
function getNextTargetDefinition(definitionArray, appSchema, title, currentConfigObject, propertyDefinition, key) {
    let nextDefinition = {
        configObject: {},
        targetDefinition: {},
        title: ''
    };
    if (definitionArray.length) {
        nextDefinition.targetDefinition = appSchema['definitions'][definitionArray[definitionArray.length - 1]];
        if (nextDefinition.targetDefinition['$ref']) {
            definitionArray = nextDefinition.targetDefinition['$ref'].split('#/definitions/');
            nextDefinition = getNextTargetDefinition(definitionArray, appSchema, title, currentConfigObject, propertyDefinition, key);
            return nextDefinition;
        }
        else if (nextDefinition.targetDefinition['type'] === 'array') {
            definitionArray = nextDefinition.targetDefinition['items']['$ref'].split('#/definitions/');
            nextDefinition = getNextTargetDefinition(definitionArray, appSchema, title, currentConfigObject, propertyDefinition, key);
            return nextDefinition;
        }
        else if (propertyDefinition['anyOf']) {
            propertyDefinition['anyOf'].forEach((element) => {
                if (element.$ref.includes(currentConfigObject.constructor.name)) {
                    definitionArray.push(...element.$ref.split('#/definitions/'));
                }
            });
            if (definitionArray.length === 0) {
                definitionArray = propertyDefinition['anyOf'][0].$ref.split('#/definitions/');
            }
        }
        if (definitionArray.length > 2) {
            definitionArray.forEach((element) => {
                if (element != '') {
                    nextDefinition.targetDefinition['properties'] = Object.assign(Object.assign({}, nextDefinition.targetDefinition['properties']), appSchema['definitions'][element]['properties']);
                }
            });
        }
        nextDefinition.title =
            nextDefinition.targetDefinition && nextDefinition.targetDefinition['title']
                ? nextDefinition.targetDefinition['title']
                : title;
        nextDefinition.configObject = currentConfigObject;
    }
    else {
        //e.g. sections ==> loop over all properties = subsections or other
        nextDefinition.targetDefinition = propertyDefinition;
        nextDefinition.title = nextDefinition.targetDefinition['title']
            ? nextDefinition.targetDefinition['title']
            : key;
        nextDefinition.configObject = currentConfigObject;
    }
    return nextDefinition;
}
exports.getNextTargetDefinition = getNextTargetDefinition;
/**
 * Method adds definition for 'RelatedFacetKeys' as enum with describtion and adds references to 'RelatedFacetKeys' for custom section definitions.
 * @param {object} schema App specific schema that potentially gets enhanced
 * @param {string[]>} sectionDefinitions array of section definitions which should be updated with new reference to 'RelatedFacetKeys' enum.
 * @param {FacetSection[]} facetSections Array of facet section objects which is used to generate enum values.
 * @param {Array<keyof Omit<FacetSection, 'custom'>>} idProperties Array of property names which should be looked up in 'FacetSection' object.
 *  Please note that method depends on order and takes first non empty value associated to passed properties.
 */
function addDefinitionForRelatedFacetKeys(schema, sectionDefinitions, facetSections, idProperties) {
    const oneOfSections = facetSections.map((section) => {
        // Loop accaptable properties in received order and find first entry with value
        const propertyName = idProperties.find((property) => !!section[property]);
        const schemaIdForSection = section[propertyName];
        return Object.assign(Object.assign({ const: schemaIdForSection }, (section.label && { description: section.label })), (section.custom && { custom: section.custom }));
    });
    // Change 'relatedFacet' only when we have entries for sections - otherwise use generic.
    if (oneOfSections.length) {
        // Create new definition in schema as 'oneOf'.
        // Simpler way would be to use 'enum', but then there no option to pass description.
        schema['definitions']['RelatedFacetKeys'] = {
            type: 'string',
            oneOf: oneOfSections
        };
        // Add enum definition
        for (const name of sectionDefinitions) {
            const definition = schema['definitions'][name];
            const property = definition['properties']['relatedFacet'];
            definition['properties']['relatedFacet'] = {
                anyOf: [
                    {
                        $ref: '#/definitions/RelatedFacetKeys'
                    },
                    property
                ]
            };
        }
    }
}
exports.addDefinitionForRelatedFacetKeys = addDefinitionForRelatedFacetKeys;
//# sourceMappingURL=utils.js.map